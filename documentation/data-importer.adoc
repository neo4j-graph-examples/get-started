= Learn how to import and map data with Neo4j Data Importer

== Introduction

This guide will teach you how to import data from flat files and how to map the data to your graph data model.

If you havent't already, please go through the _Getting started with Neo4j_ to learn the basics of Neo4j, including a brief introduction to the _graph property model_ and how this relates to the relational database model.

The _Getting started with Neo4j_ guide shows you the basics on the topic of importing data, but this guide will go more in-depth and focus solely on Data Importer. 

The topics covered in this guide are:

* Scope of Importer 
* Provision of files 
* Your model 
* Preview your import 
* Run your import 
* Exploring the resulting graph 
* Saving and loading 
* Re-running the import 
* What's next? 
* FAQ 

== Scope of Importer

Data Importer is designed to get you started with Neo4j as quickly as possible and is recommend for new users and those with rapid prototyping needs. However, it's far from being the only way to load data into Neo4j, especially when you have more advanced needs. At the end of this guide the "What's next?" step gives links to resources on the many different ways of loading data into Neo4j.

Configuring Data Importer for imnport is a simple three stage process (1) providing your Flat files, (2) defining a Graph Model and (3) Mapping that data to those flat files: 

=== Flat files

Currently, Data Importer supports the import of data from flat files.
Flat files are files that contain data in a tabular format.
Each row represents a record and each column represents a field.
The most common file formats are CSV (comma-separated values) and TSV (tab-separated values).
Data Importer supports both formats, but this guide will focus on CSV.
This guide doesn't teach you how to create CSV files, but gives you a closer look at their structure.

=== Graph Model

Once you have your flat files, your next job is to think how you're going to represent the data as nodes and relationships in your graph. Data Importer allows you to visually sketch out that model which is then use in the mapping stage. You can model and mapping iteratively as you work out which graph model best suits your use case and data.

=== Mapping

While some flat files might refer to nodes an relationshps, more often than not the nodes and relationships will be implicitly represented. The mapping stage is all about helping Data Importer understand which parts of which files represent the nodes and relationships ion the graph model. This gives Data Importer all the infomration it needs to run an Import job.  

== Provision of files

The first thing you need to do is to locate the data you want to import.
This can be individual CSV files or a directory containing multiple files.
When you know where the files are, you can drag and drop them to the _Files_ pane or browse for them.

image::files.png[]

For convenience, click the button to have the Northwind dataset loaded for you, so you don't have to drag and drop them.

button::Download the partial Northwind dataset[role=NX_IMPORT_LOAD,endpoint=https://neo4j-graph-examples.github.io/get-started/data/just-the-data.zip]

You have now _uploaded_ the files to Data Importer.
This is *not* the same as _importing_ them. 
By uploading, you just make them available to the Data Importer, not to your database.

You should now see eleven CSV files in the _Files_ section.

=== File structure

CSV files may or may not contain a header row.
The header row is the first row of the file and contains the names of the columns.
Data Importer requires a header row, which allows you to easily refer to columns by a meaningful name.
If you have a closer look at the dataset you just downloaded, you can see that the files contain a header row.
These are the first few lines of the `order-details.csv` file:

----
OrderID,ProductID,UnitPrice,Quantity,Discount
10248,11,14,12,0
10248,42,9.8,10,0
10248,72,34.8,5,0
----

This tells you that the file contains five columns and that the first column is called `OrderID`, the second `ProductID`, and so on.
Apart from the header row, it is also important that the nodes in your CSV files have _unique IDs_.
If not, you will have problems when you load the data and try to create relationships to connect the nodes.


== Thinking about your model

You are likely familiar with the _graph data model_ by now, which determines how your data is connected.
When you create your model, you need to think about the data in your CSV files and how the data is connected.
As mentioned earlier, your CSV files already contain all the information about how the data within the files is connected, you just need to sketch the model and map your data to it.
To practice, we are going to create a simple model with only two nodes and one relationship.

image::simple-model.png[]

We'll now go on to create this model and map data to it as we go.

== Create nodes

The first step is to create nodes to represent the entities in your data.
In the imported Northwind dataset, the nodes represent the customers, products, orders, and so on.
The nodes all need to have a _label_.
Remember, a label is used to identify nodes of the same type.

First, create a node by clicking the _Add node_ button and add the label `Order` by typing directly in your new node.
Alternatively, you can enter the label in the _Node name_ field in the _Mapping details_ pane on your right.
The dashed lines mean that the node is not fully mapped yet.

To fix this, you need to select what file it should map to and also what properties it should have.
Select `orders.csv` from the _File_ dropdown and then you need to add the properties you want to include.

You have two options to add properties to your node.
The most convenient way when deriving a model from your files is is to use _Select from file_.
With the `Order` node selected, go to the _Properties_ tab and click _Select from file_ and select which file columns you would like to create properties from.
This option takes all the headers of the columns in the `orders.csv` and map them as properties.
The file column name is automatically used to name the properties, but you can rename them if you like.
For example, you might like to change `orderName` to simply `name` since it's descriptive as the property is on the `Order` node.

The datatype is predicted for you, but please make sure it is correct and change as needed.
For the purpose of this model, you don't need all the available properties and can deselect `customerID` and `employeeID`.

The other option is to create your own properties by clicking _Add new_ instead. 
You need to name the property and select a data type for it.

Go to the _Mapping_ tab next.
This tab shows your selected properties and the column in `orders.csv` each property maps to.
If you created your own properties, you have to manually select which columns to map them to.

Returning to the _Definition_ tab, the last thing you need to do is to select one of the properties to represent the node as its _node ID_.
The node ID is used when connecting nodes with relationships as either a start node or end node.
If the node is referenced more than once in the file, the ID ensures that the node is not created more than once.

To move on, go ahead and create a `Product` node accordingly, using the `products.csv` file in much the same way as you did for the `Order` node.
Again, for the purpose of this example, you won't need all the available properties and can deselect `supplierID` and `categoryID`.
Use the `productID` property as ID for the node.


== Create relationships

You have two nodes and now you need to create a relationship to connect them.
Hover by the edge of the `Order` node circle and you'll see a `+` sign.
Click and hold it and you'll see another circle.
Drag the new circle on to the `Product` node and just like that, you have created a relationship. 

Just like newly created nodes, the relationship is dashed until you add mapping details.

This is the most important part, where you tell Data Importer how to link the orders to the products in your data.

First, you add the relationship type, which is a descriptive name for the relationship. 
In the model you are creating, an order _contains_ a product, so go ahead and put `CONTAINS` in the _Relationship type_ field.

Next, in order to create the relationship, you need to map a file that describes _how_ it should be created.
Remember that you selected the `orderID` and `productID` properties as IDs for the nodes.
The file you map your relationship to needs to contain these to be able to actually link the two nodes.
Look in the left pane and you'll see that the `order-details.csv` file contains both. 

You need to select from which column of the file that Data Importer should get the ID property.
In your model, the relationship goes _from_ the `Order` node, so select `orderID` for the starting node, and _to_ the `Product` node, so select `productID` for the end node.

As you can see, the file also contains other properties pertaining to the order of a product. 
You don't need to include the `orderID` or the `productID` here, as these are already encoded in the relationship.
You could include `quantity`, `unitPrice` and `discount` as properties relevant to the relationship. For example `quantity` does not belong on either the `Product` or `Order` nodes since products the will be sold in different quantities on different orders.  

=== Graph databases vs. relational databases

If you are new to graph databases but used to relational databases, some things may seem counter-intuitive.
For example, it may be hard to grasp the possibility of mapping both a relationship and a node to the same file.
The UI of Data Importer is designed to prevent you from making the most common mistakes expected from users with a background in SQL.


== Convenience features

Data Importer wants to make things easy for you and does things automatically so you don't have to.
For example, if the file you select to map a node to contains one `ID` property, Data Importer automatically uses that property as node ID.
However, if more than one property contains `ID`, or if none of them do, you have to do the selection manually.

In a simiilar fashion, the data types for your properties are also automatically selected for you.
Data Importer scans a sample of property values from each column and based on that determines what data type the property is.

If you selected your properties from file, the mapping is done for your as well.
If you created your own properties, you have to map manually.

But this doesn't mean that you can't change any of the things Data Importer have done for your convenience.
You can always select different properties, change labels and types, as well as data types.

== Ready to import?

Any dashed lines in your model means that the mapping is not complete.
If the mapping is not complete, you will not be able to run the import.

The following items **must be** mapped on a **node**:

* Label
* File
* A minimum of one property
* ID

The following items **must be** mapped on a **relationship**:

* Type
* File
* ID file columns (for both _From_ and _To_ nodes)

If you have done all your mapping and are satisfied with your model, you can _preview_ your graph before running the import.

== Preview your graph

When you're satisfied with your model and mapping, you can preview a sample of your data before running the actual import.

Click the _Preview_ button to see a sample of your data visualized.

image::preview.png[]

Even though the preview only scans the first few rows of your files, it is often sufficient to make sure everything connects as expected.
But you should keep in mind that it is only a preview and only a sample of your data.
The actual graph may look different once the full import is complete.

You want to have your mapping completely done before previewing, but if you have missed something, you are still able to do a preview, but the incomplete elements will not be rendered.
In other words, any dashed element in your model will not show up in the preview.

As mentioned before, if any element in your model is dashed, you will **not** be able to run the import.

== Running an import

You have drawn your data model, mapped every single element, and checked the preview to make sure things connect the way you intended.
That means you are ready to run the actual import.

Click _Run import_ to import the files specified in your model. 
The simple model you have created in this example only maps to three of the eleven available files.
The files not specified in your model are **not** imported, but they remain in the _Files_ section on your left.

If any mapping is incomplete, Data Importer will tell you that your model has errors and add a red exclamations mark next to the incomplete element in the model.
When you select an incomplete element, the mapping pane also highlights the missing details.

Once you've addressed the errors, go ahead and run the import again.
You should see a popup window showing the successful results.

image::import_results.png[]

The _Import results_ summarizes what was included in the import. 
You can compare to your CSV files to verify that everything was imported.
Note that if you run this guide after the _Getting Started_, the count may show _updated_ rather than _created_.

== Cypher statements

You can also see the Cypher commands used to create the elements in your model.
This can be helpful if you want to gain appreciation for the underlying Cypher required to execute the load.
Let's have a look at _Order_ nodes.
Click _Show Cypher_ on _Order_ which reveals the key statement:

.Key statement
[source,cypher]
----
CREATE CONSTRAINT `imp_uniq_Order_orderID` IF NOT EXISTS
FOR (n: `Order`)
REQUIRE (n.`orderID`) IS UNIQUE;
----

This ensures that the `orderID` is unique which is important since this is what is used later to create the relationship between the _Order_ nodes and the _Product_ nodes.
As you will see later on, this constraint is also what allows you to run the import more than once.

The load statement creates all the _Order_ nodes sets all their properties.
Both key and load statements look similar to this for the _Product_ nodes.

But let's have a look at the Cypher statement to create the relationships:

.Load statement
[source,cypher]
----
UNWIND $relRecords AS relRecord
MATCH (source: `Order` { `orderID`: toInteger(trim(relRecord.`orderID`)) })
MATCH (target: `Product` { `productID`: toInteger(trim(relRecord.`productID`)) })
MERGE (source)-[r: `CONTAINS`]->(target);
SET r.`unitPrice` = toFloat(trim(relRecord.`unitPrice`))
SET r.`quantity` = toInteger(trim(relRecord.`quantity`))
SET r.`discount` = toFloat(trim(relRecord.`discount`));
----

From this you can see how the source node and the target node are `MATCH` ed (found in the data) and then a `MERGE` statement is used to create a `CONTAINS` relationship _from_ the source node _to_ the target node.
You can also see the the properties added to each relationship.

== Explore the graph

With the data imported it's time to explore.
Go ahead and navigate to the _Explore_ tab or click the button below:

button::Explore[role=NX_TAB_NAV,tab=explore]

The _Explore_ tab allows you to visualize and interact with your data with minimal use of Cypher.
To start out, let's have a quick look at a sample of your data.

You can see that the search bar in the top left corner is already populated with _Show me a graph_.
Click the bar and press enter.
As well as showing the sample graph, you can use the search bar to find and display any of the elements in your data.
You can use near-natural language for this and that means that Explore understands a vocabulary based on the categories, labels, relationship types, property keys and property values of your dataset.

The legend panel on your right gives you an overview of the elements in your graph with one tab for nodes and one for relationships.
You can filter to show only the elements visible in the current scene or the ones not currently visible. 
If you select an element from the legend panel, you can change the styling of all the nodes/relationships with that label/type **or** apply rule-based styling based on properties.

For a more comprehensive guidance on the Explore tab, see the https://www.neo4j.com/docs/bloom-user-guide/current[Neo4j Bloom User Guide].

== Saving and loading

Now switch back to the Import tab. You have created a simple model and mapped data to it.
Often, the datamodel is a bit more complicated than this example model.
Regardless of complexity, you may want to come back to your model at some point.
Data Importer lets you _download_ your model, with or without the data you've mapped to it.

image::save-load.png[]

When you choose to download your model, with or without data, you are essentially saving it.
The model doesn't have to be mapped for you to download.

If you have a downloaded model, you can open it from this same menu, again with or without data.

The data is stored as CSV-files and the model as a json-file, which makes it easy to share.

== Run the importer again

You can run the import multiple times without duplicating your data.
For example, if you want to make some changes to your model after you've run the import, just fix your model and when you are happy run the import again.
The changes you made will overwrite what you had before, but no existing elements will be recreated.

This is due to the uniqueness constraints in the import. 
Recall the Cypher statements from the Import summary.
In case of re-running the import, this constraint ensures that if an element, with an ID, already exists, it will not be created again.

To demonstrate this, try the button below to download the entire Northwind dataset and run the import.

button::

This action will not lead to any duplication of the `Order` and `Product` nodes nor of the relationships.
To verify further, the new model calls the relationship type between `Order` and `Product` `ORDERS` instead of `CONTAINS`.
Click the button to go to the _Explore_ tab.

button::Explore[role=NX_TAB_NAV,tab=explore]

In the search bar, type _Order_ and _Product_ and press enter.
In the graph displayed in the Scene, click on any relationship and you can see it offers the `ORDERS` option as well as `CONTAINS`.
The `Order` and `Product` nodes have been retained and not recreated because their data importer configuration was identical, but since we added a new relationship type of `ORDERS`, this was added to the load. The `CONTAINS` relationship is still retained from the previous import run. The old relationships would need to be removed with Cypher, or the load run on a clean database to only keep the relationships in the latest iteration of the model and mapping. 

== When you outgrow the Data Importer

Data Importer, as a UI tool, is not best placed to meet _all_ of your varied load needs, be they transformations or differing data formats. If you can't achieve a load in Data Importer, the chances are you can achieve the load using some of the other approaches to loading data into Neo4j. The following are useful resources for different needs:

- https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/[LOAD CSV]] for writing your own bespoke Cypher load scripts from CSVs, leveraging the full capabilities of Cypher.
- https://neo4j.com/docs/operations-manual/current/tutorial/neo4j-admin-import/[Neo4j-admin import]] for loading large amounts of CSV data rapidly into an offline database
- https://neo4j.com/product/connectors/[Neo4j connectors] to connect data from a variety of soruces into Neo4j.
- https://neo4j.com/docs/apoc/current/overview/apoc.load/[APOC Load procedures] for specialist Cypher procedures to make it easier to ingest data from formats including, json, xml and arrow.

== Frequently Asked Questions

- Q: Missing files - Why does data importer say I need to provide my files after I've aready provided them? Why does it happen so often? 
A: When you provide Data Importer with your files, you are actually providing your Web Browser with a link to those files on your local filesystem, they aren't uploaded anywhere - Data importer stream the content of the files to you database only when you run the import. If you reload the page, Data Importer will lose access to the  connection to those files due to security restrictions in place to prevent web applications accessing files you haven't given express permission to use on page load. You simply need to re-provide the files when requested by data importer to be able to run an import.

- Q: How can I replace a file?
A: Data Importer doesn't currently allow you to swap out files in the UI. There is however a workaround that may prove useful. If you want to provide a different file with the same column structure to data importer, you can rename it to match and then simply add the file to the files panel. This will replace the referecne to the latest file and be available for use by your import.


- Q: How do I change the database data improter load into?
A: If you are using a Neo4j instanace that supports multiple databases, Data Importer will use the home database to import data into it.  You may have the facility to change the home database for the user that you connect to your DBMS with, read more on setting the home database for a user https://neo4j.com/docs/cypher-manual/current/access-control/manage-users/[here].






































